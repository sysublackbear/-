### Chapter6.部署

本章节主要讲两个基本的概念：**持续集成(CI - Continouous Integration )**和**持续交付(CD - Continuous Delivery)**。

1. 持续集成简介

   CI能够保证新提交的代码与已有代码进行集成，从而让所有人保持同步。CI服务器会检测到代码已提交并签出，然后花些时间来验证代码是否通过编译以及测试能否通过。

   作为这个流程的一部分，我们经常会生成一些构建物以供后续验证使用，比如启动一个服务并对其运行测试。

   CI的好处：

   + 通过它，我们能够得到关于代码质量的某种程度的快速反馈；
   + CI可以自动化生成二进制文件；
   + 用于生成这些构建物的所有代码都在版本的控制之下，所以如果需要的话，可以重新生成这个版本的构建物；
   + 通过CI我们能够从已部署的构建物回溯到相应的代码，有些CI工具，还可以使在这些代码和构建物上运行过的测试可视化。

2. 把持续集成映射到微服务

   当持续集成遇上微服务时，需要考虑如何把CI的构建和每个微服务映射起来。有下面几种做法：

   + 所有的代码，只有一个构建。向该代码库任何一次的代码提交都会触发构建，在这个构建中我们会运行与所有微服务相关的验证，然后产生多个构建物，所有这些都在同一个构建中完成。好处是关心的地方更少，处理起来方便，部署的成本也低。但也有很多明显的缺点，往往一行的代码的改动，所有的服务都需要进行验证和构建，而事实上它们或许并不需要重新进行验证和构建，所以这里会花费不必要的时间。而且，这一行的修改如果导致构建失败，那么在构建得到修复之前，与其他服务相关的代码也无法提交。
   + 保留一个代码库，但是存在多个CI会分别映射到代码库的不同部分。如果代码库的目录结构定义得合理，就会很容易把其中一部分映射到一个构建中。这是个双刃剑，一方面它会简化检出/检入的流程，但另一方面，它会让你觉得同时提交多个服务的修改是一件很容易的事情，从而做出将多个服务耦合在一起的修改。
   + 最好的方法是：每个微服务都有自己的CI，这样就可以在将该微服务部署到生产环境之前做一个快速的验证。每个微服务都有自己的代码库，分别与相应的CI绑定。当对代码库进行修改时，可以只运行相关的构建以及其中的测试。我只会得到一个需要部署的构建物，代码库与团队所有权的匹配程度也更高了。如果你对一个服务负责，就应该同时对相关的代码库和构建负责。在这样的世界中，跨微服务做修改会更加困难，但是，相比单块代码库和单块构建流程所带来的问题而言，这个问题更容易解决。

3. 构建流水线和持续交付

   将构建分解成为多个阶段，从而得到我们熟知的构建流水线。在第一个阶段运行快速测试，第二个阶段运行耗时测试。构建流水线可以很好地跟踪软件构建进度：每完成一个阶段，就离终点更近一步。CD基于构建流水线，并在此之上有所发展。

   标准的构建流水线：

   编译及快速测试——>耗时测试——>用户验收测试——>性能测试——>生产环境。

4. 平台特定的构建物

   大多数技术栈都有相应的构建物类型，同时也有相关的工具来创建和安装这些构建物。

   但是从微服务部署的角度来看，有些技术栈中的只有构建物本身是不够的。

   另一个问题是，不同技术栈生成的构建物各不相同，所以混合不同的构建物进行部署就会很复杂。

5. 操作系统级别的构建物

   有一种方法可以避免多种技术栈下的构建物所带来的问题，那就是使用操作系统支持的构建物。

   使用OS特定构建物的好处是，在做部署时不需要考虑底层使用的是什么技术。

   其缺点是：刚开始编写构建脚本的过程可能会比较困难。

   当然这会产生另一个缺点，即如果你需要部署到多种操作系统的话，维护不同版本构建物的开销就会很大。

   如果在Linux上工作，而且采用多种技术栈来部署微服务，那么这种方法就非常适合。

6. 定制化镜像

   很多的工具支持定制化镜像。但是启动的时间长，成本高。

   一种减少启动时间的方法是创建一个虚拟机镜像，其中包含一些常用的依赖。只需要构建以此镜像，然后根据这些镜像启动虚拟机是，不需要再花费时间来安装相应的依赖，因为它们已经在镜像中安装好了，这样就可以节省很多时间。

   但这也有缺点：构建镜像会花费大量的时间。其次，产生的镜像可能会很大。

   + 将镜像作为构建物：我们可以把服务本身也包含在镜像中，这样就把镜像变成了构建物。现在当你启动镜像时，服务就已经就绪了。Netflix就是因为这个快速启动的好处，把自己的服务内建在了AWS AMI中。
   + 不可变服务器：
     + 产生的背景是：通过把配置都存到版本控制中，我们可以自动化重建服务，甚至重建整个环境。但是如果部署完成后，有人登录到机器上修改了一些东西呢？这就会导致机器上的实际配置和源代码管理中的配置不再一致，这个问题叫作配置漂移。
     + 为了避免这个问题，可以禁止对任何运行的服务器做手动修改。相反，无论修改多么小，都需要经过构建流水线来创建新的机器。事实上，即使不使用镜像，你也可以实现类似的模式，但它是把镜像作为构建物的一个非常合理的扩展。你甚至可以在镜像的创建过程中禁止SSH，以确保没有人能够登录到机器上做任何修改。

7. 环境

   一般来说，CD流水线需要具备如下4个环境：一个用来运行耗时测试，一个用来做UAT，一个用来做性能测试，另一个用于生产环境。

   从头到尾，构建物只有一个，但是环境不同，这样会引入其他的问题，比如：我们的生产环境可能会包括两个数据中心的多台主机，使用负载均衡来管理，而测试环境可能会把所有的服务运行在一台机器上。这些环境之间的不同可能会引起一些问题。（测试环境混布服务严重，容易出现资源抢占问题）

8. 服务配置

   服务需要一些配置。理想情况下，这些配置的工作量应该很小，而且仅仅局限于环境间的不同之处，比如用来连接数据库的用户名和密码。应该最小化环境间配置的差异。如果你的配置修改了很多服务的基本行为，或者不同环境之间的配置差异很大，那么你可能就只能在一套环境中发现某个特定的问题，这是极其痛苦的事情。

   解决方法有：

   + 对每个环境创建不同的构建物，并把配置内建在该构建物中。但是这样引入的问题是，你通过测试的版本并非是你最终要发布到生产环节的版本。
   + 一个更好的办法是只创建一个构建物，并将配置单独管理。从形式上来说，这针对的可能是每个环境的一个属主文件，或者是传入到安装过程中的一些参数。还有一个在应对大量微服务时比较流行的方法是，使用专用系统来提供配置。

9. 服务与主机之间的映射

   注意，现代更倾向于使用“主机”这个词来做通用的隔离单元，也就是能够运行服务的一个操作系统。

   那么在考虑不同的部署模型是，每台主机应该有多少个服务呢？

   + 单主机多服务：

     + 这个模型的好处是简化开发人员的工作，因为将多个服务部署在生成环境的单个主机上，与把多个服务部署在本地开发机上的过程很类似。
     + 但是缺点是：
       + 使得监控变得更加困难，资源会发生抢占。
       + 而且，服务的部署也会变得越来越复杂，很难保证对一个服务的部署不会影响其他的服务。
       + 对团队的自治性也不利。
       + 限制部署构建物的选择。
       + 增加了对单个服务进行扩展的复杂性。

   + 应用程序容器：

     + 好处有：节省语言运行时的开销。比如，在一个Java servlet容器中部署五个Java服务的话，只需要启动一个JVM即可。
     + 缺点1：它会不可避免地限制技术栈的选择。你只能使用一种技术栈。
     + 缺点2：限制自动化和系统管理技术的选择。

   + 每个主机一个服务

     这种模型避免了单主机多服务的问题，并简化了监控和错误恢复。这种方式也可以减少潜在的单点故障。一台主机宕机只会影响一个服务，虽然在虚拟化平台上不一定真的是这样。

     但主机数量的增加也可能是个问题。管理更多的服务器，运行更多不同的主机也会引入很多的隐式代价。尽管存在这些问题，但我仍然认为在使用微服务架构时这是比较好的模型。

   + 平台即服务（Platform-as-a-Service PASS）

     当你使用Paas时，你工作的抽象层次要比单个主机上工作时的高。这些平台依赖于特定技术的构建物，会帮你自动配置机器然后运行。其中一些能够透明地对系统进行伸缩管理，而且，允许你控制运行服务的节点数量，然后平台帮你处理其余的工作。

10. 自动化：说了一些使用自动化方案的一些好处。

11. 从物理机到虚拟机

    管理大量主机的关键之一是，找到一些方法把现有的物理机划分成小块。

    + 传统的虚拟化技术：VM方案本身也会占用额外的空间，产生额外的开销；
    + Vagrant：可以了解一下，但本身也会有额外的资源消耗。
    + Linux容器：可以创建一个隔离的进程空间，进而在这个空间中运行其他的进程。容器相对上面两种方案更加轻量级。
    + Docker：Docker 是构建轻量级容器之上的平台。它帮你处理了大多数与容器管理相关的事情。（清楚几个概念：IaaS基础设施即服务，PaaS，CaaS容器即服务。

12. 一个部署接口

    不管用于部署的底层平台和构建物是什么，使用统一接口来部署给定的服务都是一个很关键的实践。比如：提供三个参数构成一个部署脚本

    ```bash
    $ deploy artifact=catalog environment=local version=local
    ```

    使用的比较多的工具有：Fabric

    ​