### Chapter6.部署

本章节主要讲两个基本的概念：**持续集成(CI - Continouous Integration )**和**持续交付(CD - Continuous Delivery)**。

1. 持续集成简介

   CI能够保证新提交的代码与已有代码进行集成，从而让所有人保持同步。CI服务器会检测到代码已提交并签出，然后花些时间来验证代码是否通过编译以及测试能否通过。

   作为这个流程的一部分，我们经常会生成一些构建物以供后续验证使用，比如启动一个服务并对其运行测试。

   CI的好处：

   + 通过它，我们能够得到关于代码质量的某种程度的快速反馈；
   + CI可以自动化生成二进制文件；
   + 用于生成这些构建物的所有代码都在版本的控制之下，所以如果需要的话，可以重新生成这个版本的构建物；
   + 通过CI我们能够从已部署的构建物回溯到相应的代码，有些CI工具，还可以使在这些代码和构建物上运行过的测试可视化。

2. 把持续集成映射到微服务

   当持续集成遇上微服务时，需要考虑如何把CI的构建和每个微服务映射起来。有下面几种做法：

   + 所有的代码，只有一个构建。向该代码库任何一次的代码提交都会触发构建，在这个构建中我们会运行与所有微服务相关的验证，然后产生多个构建物，所有这些都在同一个构建中完成。好处是关心的地方更少，处理起来方便，部署的成本也低。但也有很多明显的缺点，往往一行的代码的改动，所有的服务都需要进行验证和构建，而事实上它们或许并不需要重新进行验证和构建，所以这里会花费不必要的时间。而且，这一行的修改如果导致构建失败，那么在构建得到修复之前，与其他服务相关的代码也无法提交。
   + 保留一个代码库，但是存在多个CI会分别映射到代码库的不同部分。如果代码库的目录结构定义得合理，就会很容易把其中一部分映射到一个构建中。这是个双刃剑，一方面它会简化检出/检入的流程，但另一方面，它会让你觉得同时提交多个服务的修改是一件很容易的事情，从而做出将多个服务耦合在一起的修改。
   + 最好的方法是：每个微服务都有自己的CI，这样就可以在将该微服务部署到生产环境之前做一个快速的验证。每个微服务都有自己的代码库，分别与相应的CI绑定。当对代码库进行修改时，可以只运行相关的构建以及其中的测试。我只会得到一个需要部署的构建物，代码库与团队所有权的匹配程度也更高了。如果你对一个服务负责，就应该同时对相关的代码库和构建负责。在这样的世界中，跨微服务做修改会更加困难，但是，相比单块代码库和单块构建流程所带来的问题而言，这个问题更容易解决。

3. 构建流水线和持续交付

   将构建分解成为多个阶段，从而得到我们熟知的构建流水线。在第一个阶段运行快速测试，第二个阶段运行耗时测试。构建流水线可以很好地跟踪软件构建进度：每完成一个阶段，就离终点更近一步。CD基于构建流水线，并在此之上有所发展。

   标准的构建流水线：

   编译及快速测试——>耗时测试——>用户验收测试——>性能测试——>生产环境。

4. 平台特定的构建物

   大多数技术栈都有相应的构建物类型，同时也有相关的工具来创建和安装这些构建物。

   但是从微服务部署的角度来看，有些技术栈中的只有构建物本身是不够的。

   另一个问题是，不同技术栈生成的构建物各不相同，所以混合不同的构建物进行部署就会很复杂。

5. 操作系统级别的构建物

   有一种方法可以避免多种技术栈下的构建物所带来的问题，那就是使用操作系统支持的构建物。

   使用OS特定构建物的好处是，在做部署时不需要考虑底层使用的是什么技术。

   其缺点是：刚开始编写构建脚本的过程可能会比较困难。

   当然这会产生另一个缺点，即如果你需要部署到多种操作系统的话，维护不同版本构建物的开销就会很大。

   如果在Linux上工作，而且采用多种技术栈来部署微服务，那么这种方法就非常适合。

6. 定制化镜像

   很多的工具支持定制化镜像。但是启动的时间长，成本高。

   一种减少启动时间的方法是创建一个虚拟机镜像，其中包含一些常用的依赖。只需要构建以此镜像，然后根据这些镜像启动虚拟机是，不需要再花费时间来安装相应的依赖，因为它们已经在镜像中安装好了，这样就可以节省很多时间。

   但这也有缺点：构建镜像会花费大量的时间。其次，产生的镜像可能会很大。

   + 将镜像作为构建物

7. 2121

8. s