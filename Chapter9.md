### Chapter9.安全

面对安全问题，我们往往需要考虑的以下几个点：

+ 在数据从一个点到另一个点的传输过程中，如何保护它们，也需要考虑在其他情况下如何进行保护。
+ 底层操作系统及网络的安全；
+ 人的因素。



1. 身份验证和授权：当谈到与我们系统交互的人和事时，最核心的两个概念是**身份验证**和**授权**。在安全领域中，身份验证是确认他是谁的过程，通过密码或指纹的信息进行验证。通过授权机制，可以把主体映射到他可以进行的操作中。（某些框架已经集成了用户管理的功能）
   + 常见的单点登录实现：身份验证和授权的一种常用方法是：使用某种形式的SSO解决方案。在企业级领域中占据统治地位的**SAML**和**OpenID Connect**，也提供了这方面的能力。OpenID Connect使用LDAP或活动目录。（未来的趋势）SMAL却基于SOAP的标准。
   + 单点登录网关：
     + 在微服务系统中，每个服务可以自己处理如何重定向到身份提供者，并与其进行握手。显然，这意味着大量的重复工作。使用共享库可以解决这个问题，但我们必须小心地避免可能来自代码的耦合。而且如果有多个不同的技术栈，共享库也很难提供帮助。
     + 你可以才用网关的方法，作为代理，而不是让每个服务管理与身份提供者握手。基本想法是：我们可以集中处理重定向用户的行为，并且只在一个地方执行握手。
     + 那么，我们怎么解决下游服务如何接受主体信息的问题，比如如果使用HTTP，可以把这些信息放在HTTP头上。
     + 但是这种方法有很大的缺点是：相当于把所有的鸡蛋都放在同一个篮子里面。当这个点发生故障了，会发生很严重的问题。
   + 细粒度的授权：网关可以提供相当有效的粗粒度的身份验证。面对细粒度的授权，应该放在微服务内部去进行管理。

2. 服务间的身份验证和授权：
   + 在边界内允许一切：我们的首要选项是，在边界内对服务的任何调用都是默认可信的。虽然这种方案对典型的中间人攻击没有任何的防备，但是基于成本，我们大概率还是使用这种隐性的信任模型。

   + HTTP(S)基本身份验证：
     + HTTP：允许客户端在标准HTTP头中发送用户名和密码。服务端可以验证到这些信息，并确认客户端是否有权访问服务。这样做的好处在于，这是一种非常容易理解并且得到广泛支持的协议。问题在于，通过HTTP有很高的风险，因为用户和密码并没有以安全的方式发送。任何中间方都可以看到HTTP头的信息并读取里面的数据。因此，HTTP基本身份验证通常应该通过HTTPS进行通信。
     + HTTPS：使用HTTPS时，客户端得到强有力的保证，它所通信的服务端就是客户端想要通信的服务端。它给予我们额外的保护，避免人们窃听客户端和服务端之间的通信，或篡改有效负载。但是，服务端需要管理自己的SSL证书，当需要管理多台机器时会出现。一些组织自己承担签发证书的过程，这是一个额外的行政和运营负担。而且，SSL之上的流量不能被反向代理服务器所缓存，这是HTTPS的另一个缺点。这意味着，如果你需要缓存信息，就不得不在服务端或客户端内部实现。你可以在负载均衡中把Https的请求转成Http的请求，然后在负载均衡之后就可以使用缓存了。**但是**，注意使用这个方法，服务器只知道客户端有用户名和密码。我们不知道这个信息这个信息是否来自我们期望的机器；它可能来自网络中的其他人。（防不了中间人攻击）

   + 使用SAML或OpenID Connect：如果想要解决上面的问题，客户端需要维护一组凭证，用于向身份提供者验证自身，而服务获取所需的信息，用于任何细粒度的身份验证。这意味着你需要为客户端创建账户，有时被称为服务账户。许多组织普遍使用这种方法。不过，需提醒一句：如果你打算创建服务账户，应尽量限制其使用范围。因此，考虑每个微服务都要有自己的一组凭证。如果凭证被泄露，你只需撤销有限的受影响的凭证即可，这使得撤销/更改访问更简单。（微服务证书）然而，这还有几个缺点，首先我们需要安全地存储凭证；另外，实现技术繁琐。

   + 客户端证书：确认客户端身份的另一种身份是，使用TLS（安全传输层协议），TLS是SSL在客户端证书方面的继任者。在这里，每个客户端都安装了一个X.509证书，用于客户端和服务器端之间建立通信链路。服务器可以验证客户端证书的真实性，为客户端的有效性提供强有力的保证。但弊端是证书管理的工作要比只使用服务端证书更加繁重。

   + HTTP之上的HMAC：如上面所说，除了需要管理证书，HTTPS通信的开销使得服务器压力增加，而且通信难以被轻松地缓存。另一种方法是使用HMAC（基于哈希的消息码）对请求进行签名，它是OAuth规范的一部分，并被广泛应用于亚马逊AWS的S3 API。

     + *使用HMAC*，请求主体和私有密钥一起被哈希处理，生成的哈希值随请求一起发送。然后，服务器使用请求主体和自己的私钥副本重建哈希值。如果匹配，它便接受请求。这样做的好处是，如果一个中间人更改了请求，那么哈希值会不匹配，服务器便知道该请求已被篡改过。并且，私钥永远不会随请求发送，因此不存在传输中被泄露的问题。额外的好处是，这个通信更容易被缓存，而且生成哈希的开销要低于处理HTTPS通信的开销。
     + 但是使用HMAC有三个缺点：a.客户端和服务器需要一个共享的，以某种方式交流的密钥。但是如何共享？硬编码的话，被泄漏后，需要撤销访问，需要服务重编上线。如果你使用替代的密钥来，那么需要另一套安全的机制去保证协议的安全。b.这是一种模式，缺乏一个优秀的，开放的且有效的实现方式。c.要理解这种方法只能保证第三方无法篡改请求，且私钥本身不会泄露。但请求中所带的其他数据，对网络嗅探来说仍是可见的。

   + API密钥：对于著名的服务商，提供的所有公共API都使用API密钥。API密钥允许服务识别出是谁在进行调用，然后对他们能做的进行限制。限制通常不仅限于特定资源的访问，还可以扩展到类似于针对特定的调用者限速，以保护其他人服务调用质量等。

     具体还如何使用API密钥方式来处理你的微服务间的访问，取决于你所使用的具体技术。一些系统使用一个共享的API密钥，并且使用一种类似于刚才说的HMAC的方式。更常见的方法是，使用一个公钥私钥对。通常情况下，正如集中管理人的身份标识一样，我们也会集中管理密钥。网关模型在这个领域很受欢迎。

   + 代理问题：注意“混淆代理人问题”的安全漏洞。比如怎么阻止商户查询不属于自己的订单。（如果允许查询，黑客容易使用钓鱼页面去欺诈其他人）

3. 静态数据的安全

   数据加密是一种责任，尤其当它是敏感数据时，应该遵循以下注意：

   + 使用众所周知的加密算法：不要尝试实现自己的加密算法，或甚至试图实现别人的。
   + 一切皆与密钥相关：密钥该如何存储呢？一个解决方案是，使用单独的安全设备来加密和解密数据。另一个方案是，使用单独的密钥库，当你的服务需要密钥的时候可以访问它。密钥的生命周期是非常重要的操作，而这些系统可以帮你处理这个事情。
   + 选择你的目标：通过把系统划分为更细粒度的服务，你要真正确定系统中真正需要加密的数据是哪一部分。
   + 按需解密：第一次看到数据的时候就对它加密。只在需要时进行解密，并确保解密后的数据不会存储在任何地方。
   + 加密备份：清晰的密钥管理变得非常重要。

4. 深度防御

   + 防火墙：有一个或多个防火墙是一个非常明智的预防措施。有些非常简单，只在特定的端口限制的通信类型。如IPTables，设置允许的入口和出口，以及可以在特定的IP范围限制连接数，并检测其他类型的恶意攻击。
   + 日志：我们必须小心那些存储在日志里的信息，注意脱敏操作，敏感信息需要被剔除，以确保没有泄露重要的数据到日志里，如果泄露的话，最终可能会成为攻击者的重要目标。
   + 入侵检测（和预防）系统：IDS（入侵检测系统）可以监控网络或主机，当发现可疑行为时报告问题。IPS（入侵预防系统）也会监控可疑行为，并进一步阻止它的发生。
   + 网络隔离：在微服务系统中，你可以把服务放进不同的网段，以进一步控制服务间的通信。甚至可以通过网关把流量路由到代理中，实际上，它提供了多个网络范围，在其中可以实施额外的安全措施。
   + 操作系统：注意修复操作系统的安全漏洞。

5. 一个示例：这个示例确实非常值得参考，详见书157页图。

6. 保持节俭：敏感的用户信息尽可能脱敏过后，或者把尽量少的信息落磁盘。

7. 人的因素：如何保证系统组织里的人为因素，如组织内的人离职心怀不满，做出损坏系统的行为。如何让系统免受社会工程学的攻击。

8. 黄金法则：那就是“不要实现自己的加密算法”。不要在安全方面尝试自己造轮子，哪怕你是一个安全专家，之前提到的很多工具在安全领域已经经历足够多的验证。

9. 内建安全：如自动化内部安全漏洞扫描软件。

10. 外部验证：包括系统内部，外部的渗透测试，来保证系统的安全性。还需要考虑，每次发布前需要多少验证。一般来说，并不是每次小的增量发布都需要做一个完整的渗透测试，可能大的变化才需要。你的需求取决于你自己能承担的风险。