### Chapter9.安全

面对安全问题，我们往往需要考虑的以下几个点：

+ 在数据从一个点到另一个点的传输过程中，如何保护它们，也需要考虑在其他情况下如何进行保护。
+ 底层操作系统及网络的安全；
+ 人的因素。



1. 身份验证和授权：当谈到与我们系统交互的人和事时，最核心的两个概念是**身份验证**和**授权**。在安全领域中，身份验证是确认他是谁的过程，通过密码或指纹的信息进行验证。通过授权机制，可以把主体映射到他可以进行的操作中。（某些框架已经集成了用户管理的功能）
   + 常见的单点登录实现：身份验证和授权的一种常用方法是：使用某种形式的SSO解决方案。在企业级领域中占据统治地位的**SAML**和**OpenID Connect**，也提供了这方面的能力。OpenID Connect使用LDAP或活动目录。（未来的趋势）SMAL却基于SOAP的标准。
   + 单点登录网关：
     + 在微服务系统中，每个服务可以自己处理如何重定向到身份提供者，并与其进行握手。显然，这意味着大量的重复工作。使用共享库可以解决这个问题，但我们必须小心地避免可能来自代码的耦合。而且如果有多个不同的技术栈，共享库也很难提供帮助。
     + 你可以才用网关的方法，作为代理，而不是让每个服务管理与身份提供者握手。基本想法是：我们可以集中处理重定向用户的行为，并且只在一个地方执行握手。
     + 那么，我们怎么解决下游服务如何接受主体信息的问题，比如如果使用HTTP，可以把这些信息放在HTTP头上。
     + 但是这种方法有很大的缺点是：相当于把所有的鸡蛋都放在同一个篮子里面。当这个点发生故障了，会发生很严重的问题。
   + 细粒度的授权：网关可以提供相当有效的粗粒度的身份验证。面对细粒度的授权，应该放在微服务内部去进行管理。
2. 服务间的身份验证和授权：
   + 在边界内允许一切：我们的首要选项是，在边界内对服务的任何调用都是默认可信的。虽然这种方案对典型的中间人攻击没有任何的防备，但是基于成本，我们大概率还是使用这种隐性的信任模型。
   + HTTP(S)基本身份验证：
     + HTTP：允许客户端在标准HTTP头中发送用户名和密码。服务端可以验证到这些信息，并确认客户端是否有权访问服务。这样做的好处在于，这是一种非常容易理解并且得到广泛支持的协议。问题在于，通过HTTP有很高的风险，因为用户和密码并没有以安全的方式发送。任何中间方都可以看到HTTP头的信息并读取里面的数据。因此，HTTP基本身份验证通常应该通过HTTPS进行通信。
     + HTTPS：使用HTTPS时，客户端得到强有力的保证，它所通信的服务端就是客户端想要通信的服务端。它给予我们额外的保护，避免人们窃听客户端和服务端之间的通信，或篡改有效负载。但是，服务端需要管理自己的SSL证书，当需要管理多台机器时会出现。一些组织自己承担签发证书的过程，这是一个额外的行政和运营负担。而且，SSL之上的流量不能被反向代理服务器所缓存，这是HTTPS的另一个缺点。这意味着，如果你需要缓存信息，就不得不在服务端或客户端内部实现。你可以在负载均衡中把Https的请求转成Http的请求，然后在负载均衡之后就可以使用缓存了。**但是**，注意使用这个方法，服务器只知道客户端有用户名和密码。我们不知道这个信息这个信息是否来自我们期望的机器；它可能来自网络中的其他人。（防不了中间人攻击）
   + 使用SAML或OpenID Connect：如果想要解决上面的问题，客户端需要维护一组凭证，用于向身份提供者验证自身，而服务获取所需的信息，用于任何细粒度的身份验证。这意味着你需要为客户端创建账户，有时被称为服务账户。许多组织普遍使用这种方法。不过，需提醒一句：如果你打算创建服务账户，应尽量限制其使用范围。因此，考虑每个微服务都要有自己的一组凭证。如果凭证被泄露，你只需撤销有限的受影响的凭证即可，这使得撤销/更改访问更简单。（微服务证书）然而，这还有几个缺点，首先我们需要安全地存储凭证；另外，实现技术繁琐。
   + 客户端证书：确认客户端身份的另一种身份是，使用TLS（安全传输层协议），TLS是SSL在客户端证书方面的继任者。在这里，每个客户端都安装了一个X.509证书，用于客户端和服务器端之间建立通信链路。服务器可以验证客户端证书的真实性，为客户端的有效性提供强有力的保证。但弊端是证书管理的工作要比只使用服务端证书更加繁重。
   + HTTP之上的HMAC：如上面所说，除了需要管理证书