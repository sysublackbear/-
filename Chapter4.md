### chapter4.集成

集成是微服务相关技术中最重要的一个。做得好的话，你的微服务可以保持自治性，你也可以独立地修改和发布它们，但做得不好的话会带来灾难。

1. 寻找理想的集成技术：需要考虑的是

   + 避免**破坏性修改**：有时候，对某个服务做的一些修改会导致该服务的消费方也随之发生改变，但是我们希望选用的技术可以尽量避免这种情况的发生。比如，如果一个微服务在一个响应中添加了一个字段，那么已有的消费方不应该受到影响。
   + 保证API的技术无关性：不应该选择那种对微服务的具体实现技术有限制的集成方式。
   + 是你的服务易于消费方使用：消费方应该能很容易使用我们的服务。可以考虑提供一个客户端库，可以简化消费方的使用。但是，使用客户端库对于消费方来说很方便，但是会造成耦合的增加。
   + 隐藏内部实现细节：我们不希望消费方与服务的内部实现细节绑定在一起，因为这会增加耦合。与细节绑定意味着，如果想要改变服务内部的一些实现，消费方就需要跟着做出修改，这会增加修改的成本，而这恰恰是我们想要避免的。这也会导致为了避免消费方的修改而尽量少对服务本身进行修改，而这会导致服务内部技术债的增加。所以，所有倾向于暴露内部实现细节的技术都不应该被采用。

2. 为用户创建接口

3. 共享数据库：例子展示了一个修改网站采用数据库集成对客户数据库进行平等地位的修改。但是实践起来会发现有很多的困难：

   + 这使得外部系统能够查看内部实现细节，并与其绑定在一起。存储在数据库中的数据结构对所有人来说都是平等的，所有服务都可以完全访问该数据库。如果我决定为了更好地表示数据或者增加可维护性而修改表结构的话，我的消费方就无法进行工作。数据库是一个很大的共享API，但同时也非常不稳定。如果我想改变与之相关的逻辑，比如说帮助台如何管理客户，这就需要修改数据库。为了不影响其他服务，我必须非常小心地避免修改与其他服务相关的表结构。这种情况下，通常需要做大量的回归测试来保证功能的正确性。
   + 其次，消费方与特定的技术选择绑定在一起了。现在看关系型数据存储是合理的，一旦后面需要使用非关系型数据库，消费方和客户服务非常紧密地绑定了在一起，那么能够轻易替换这个数据库吗？
   + 最后，考虑一下行为。肯定会有一部分逻辑负责对客户进行修改。那么这个逻辑应该放在什么地方呢？如果消费直接操作数据库，那么它们都需要对这些逻辑负责。对数据库进行操作的相似逻辑可能会出现在很多服务中。如果仓库，注册界面，呼叫中心都需要编辑客户的信息，那么当修复一个bug的时候，你需要修改三个不同的地方，并且对这些修改分别做部署。这样就会失去内聚性。

4. 同步和异步：这里需要区分清楚同步和异步的差别，以及请求/响应或者基于事件的协作方式的差别。异步也可以使用请求/响应的的模式，客户端发起一个请求，然后注册一个回调，当服务端操作结束之后，会调用该回调。对于使用基于事件的协作方式来说，情况会颠倒过来。客户端不是发起请求，而是发布一个事件，然后期待其他的协作者接收到该消息，并且知道该怎么做。基于事件的系统天生就是异步的。业务逻辑并非集中存在于某个核心大脑，而是平均地分布在不同的协作者中。基于事件的协作方式耦合性很低。

5. 编排与协同：对于业务流程的具体实现而言，会有两种架构风格可以采用：

   + 编排：依赖于某个中心大脑来指导并驱动整个流程。缺点在于中心控制点承担了太多的职责，它会成为网状结构的中心枢纽及很多逻辑的起点。我见过这个方法会导致少量的”上帝“服务，而与其打交道的那些服务通常都会沦为贫血的，基于CRUD的服务。
   + 协同：我们仅会告知系统中各个部分各自的职责，而把具体怎么做的细节留给它们自己。通过事件发布和订阅的方式，显著地消除耦合，如果其他服务也关系该类事件，简单地订阅即可。缺点是从流程图上缺乏明显的业务流程视图。而且，需要一些额外的工作来监控流程，以保证其正确地进行。需要对业务流程做跨服务的监控。
   + 总而言之，需要综合考虑。同步调用比较简单，而且很容易知道整个流程的工作是否正常。如果想要请求/响应风格的语义，又想避免其在耗时业务上的困境，可以采用异步请求加回调的方式。另一方面，使用异步方案有利于协同方案的实施，从而大大减少服务间的耦合，这恰恰就是我们为了能独立发布服务而追求的特性。

   **针对请求/响应方式**，可以考虑两种技术：RPC（远程过程调用）和 REST（表述性状态转移）。

6. RPC：RPC依赖于接口定义（SOAP，Thrift，protocol buffers）。不同的技术栈可以通过接口定义轻松地生成客户端和服务端的桩代码。

   + 部分RPC技术会带来技术的耦合，值得注意。
   + 本地调用和远程调用并不相同：RPC的核心想法是隐藏远程调用的复杂性。但是很多RPC的实现隐藏得有些过头了，进而会造成一些问题。使用本地调用不会引起性能问题，但是RPC会花大量的时间对负荷进行封装和解封装，更别提网络通信所需要的时间。这意味着，要使用不同的思路来设计远程和本地的API。简单地把一个本地的API改造成跨服务的远程API往往会带来问题。
   + 脆弱性：由于rpc使用的二进制流，通信双方使用的数据类型会直接被序列化和反序列化。所以，通信的结构并不支持删除字段和修改原来的字段结构。

7. REST：REST是受Web启发而产生的一种架构风格，主要围绕着资源进行操作，一个资源的对外显示方式和内部存储方式之间没有什么耦合。

   + REST通常会和HTTP一起使用。
   + 服务端使用标准文本形式的响应：JSON，XML还是其他。
   + 基于HTTP的REST的缺点：(1).从易用性的角度，基于HTTP的REST无法帮助你生成客户端的桩代码，而RPC可以，基于HTTP的客户端库支持也不算很好；(2).有些Web框架无法很好地支持所有的HTTP动词，尤其是PUT和DELETE；(3).性能上来说REST也可能会遇到问题，在要求低延迟的场景下，每个HTTP请求的封装开销可能是个问题，远没有RPC的建立TCP或UDP协议来的快速。

8. 实现基于事件的异步协作方式

   主要有两个部分需要考虑：微服务发布事件机制和消费者接收事件机制。

   (1).技术选择：

   + 传统上来说，消息代理能够处理上述两个方面的问题。生产者使用API向代理发布事件，代理也可以向消费者提供订阅服务，并且在事件发生时通知消费者。这种代理甚至可以跟踪消费者的状态，比如标记哪些消息是该消费者已经消费过的。这种系统通常具有较好的可伸缩性和弹性，但这么做也是有代价的。它会增加开发流程的复杂度，因为你需要一个额外的系统（即消息代理）才能开发及测试服务。你也需要额外的机器和专业知识来保持这些基础设施的正常运行。但一旦做好了，它会是实现松耦合，事件驱动架构的一种非常有效的方法。
   + 另一种方法是使用HTTP来传播事件。ATOM是一个符合REST规范的协议，可以通过它提供资源聚合(feed)的发布服务，而且有很多现成的客户端库可以用来消费该聚合。

   如果使用消息代理，一个标准的队列就可以很好地处理这种场景。而使用ATOM的话，就需要自己在所有的工作者之间维护一个共享的状态。

   (2).异步架构的复杂性：易引入灾难性故障转移，需要实现消息医院（死信队列）。

9. 服务即状态机

10. 响应式扩展：响应式扩展提供了一种机制，在此之上，你可以把多个调用的结果组装起来并在此基础上执行操作。调用本身可以是阻塞或者非阻塞的。响应式扩展改变了传统的流程，以往我们会获取一些数据，然后基于此进行操作，现在你可以做的是简单地对操作的结果进行观察，结果会根据相关数据的改变自动更新。一些响应式扩展的实现允许你对这些被观察者应用某种函数变换。很多响应式扩展的实现在分布式系统中找到了归宿。因为调用的细节被屏蔽了，所以事情也更容易处理，我们可以简单地对下游服务调用的结果进行观察，而不需要关心它是阻塞的还是非阻塞的，唯一需要做的就是等待结果并做出响应。好处是可以把多个不同的调用组合起来，这样就可以更容易地对下游服务的并发调用做处理。

11. 微服务世界中的DRY和代码重用的危险

    DRY：Don‘t Repeat Yourself：避免重复代码，避免系统行为和知识的重复。通过DRY可以得到重用性较好的代码，但也会导致共享代码带来的服务和消费者耦合。因此，总结出来的经验是：**在微服务内部不要违反DRY，但在跨服务的情况下可以适当违反DRY。服务之间引入大量的耦合会比重复代码带来更糟糕的问题。**

12. 按引用访问：

    + 有时候使用本地副本没什么问题，但在其他场景下你需要知道该副本是否已经失效。所以，当你持有一个本地副本时，请确保同时持有一个指向原始资源的引用，这样在你需要的时候就可以对本地副本进行更新。
    + 当然在使用引用时也需要做一些取舍。如果总是从客户服务去查询给定客户的相关信息，那么客户服务的负载就会过大。如果在获取资源的同时，可以得到资源的有效性时限信息的话，就可以进行相应的缓存。

13. 版本管理

    + 尽可能推迟破坏性修改：尽量不要做这样的改动；鼓励客户端的正确行为，避免过早地将客户端和服务端紧密绑定起来。客户端尽可能灵活地消费服务响应，坚持鲁棒性原则，每个模块应该”宽进严出”，即对自己发送的东西要严格，对接收的东西则要宽容。这个原则最初的上下文是网络设备之间的交互，因为在这个场景中，所有的奇怪事情都有可能发生。在请求/响应的场景下，该原则可以帮助我们在服务发生改变时，减少消费方的修改。
    + 及早发现破坏性修改：并尽快跟维护服务的人员沟通。
    + 使用语义化的版本管理：语义化版本管理的每一个版本号都遵循这样的格式：MAJOR.MINOR.PATCH（如：1.2.0，1.3.0，2.0.0等）。其中MAJOR的改变意味着其中包含向后不兼容的修改（客户端需要重编）；MINOR的改变意味着有新功能的增加，但应该是向后兼容的（客户端不需要重编）；最后，PATCH的改变代表对已有功能的缺陷修复（客户端不需要重编）。
    + 不同的接口共存：主要是老API和新API的交替过程。对于使用http的系统而言，可以通过在请求中添加版本信息，也可以在URI中添加版本号，如：/v1/customer 和 /v2/customer。对于RPC来说，可以考虑在pb方法放到不同的命名空间中，但是当你尝试在网络上对相同类型的不同版本进行传输时，就会非常痛苦。
    + 同时使用多个版本的服务：短期内同时使用两个版本的服务时合理的，尤其是当你做蓝绿部署或者金丝雀发布时。在这些情况下，不同版本的服务可能只会共存几分钟或者几个小时，而且一般只会有两个版本。升级消费者到新版本的时间越长，就越应该考虑在同一个微服务中暴露两套API的做法。我对于共存两个服务的这种做法，是否适用于一般的项目保持怀疑态度。

14. 用户界面

    + 走向数字化；
    + 约束：基于交互形式的约束；
    + API组合：这会存在一个问题，首先很难为不同的设备定制不同的响应。其次，维护服务的人往往不是服务的使用者。如果UI是另一个团队创建的，我们可能会退回到以前那种分层合作模式，在这种模式下即使很小的修改都需要多个团队的参与（洋葱架构）；
    + UI片段的组合：相比UI主动访问所有的API，然后再将状态同步到UI控件，另一种选择是让服务直接暴露出一部分UI，然后只需要简单地把这些片段组合在一起就可以创建出整体UI。这些粗粒度的片段由服务端程序提供，而这些程序又会去调用相关的API。但这种方法也会有这样的问题：原生应用和胖客户无法消费服务端提供的UI组件。以及，有时候服务提供的能力难以嵌入到小部件或者页面中。
    + 为前端服务的后端：相当于专门为了对接UI而抽象出来的逻辑服务后端层，保证一个这样的后端只为一个应用或者用户界面服务。

15. 与第三方软件集成的特点

    + 缺乏控制；
    + 需要定制化；
    + 意大利面式的集成；
    + 在自己可控的平台进行定制化；
    + 在对新老系统的交替，可以选择使用绞杀者模式。

16. 小结：以下的选择能够最大程度低保证微服务之间的低耦合：

    + 无论如何避免数据库集成；
    + 理解REST 和 RPC 之间的取舍，但总是使用REST 作为请求/响应模式的起点；
    + 相比编排，优先选择协同；
    + 避免破坏性修改，理解Postel法则，使用容错性读取器；
    + 将用户界面视为一个组合层。

