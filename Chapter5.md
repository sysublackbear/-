### Chapter5.分解单块系统

小服务能够达到更好的效果，然而单块系统的形成非一日之功。开发人员每天都对系统添加新功能和新代码。一段时间之后，它变成了组织中一个恐怖而巨大的存在。但别担心，它并不是无可救药。只要使用了正确的工具，我们就可以手刃这个怪兽。

1. 关键是接缝

   + 接缝的定义：从接缝处可以抽取出相对独立的一部分代码，对这部分代码进行修改不会影响系统的其他部分。识别出接缝不仅仅能够清理代码库，更重要的是，这些被识别出的接缝可以成为服务的边界。
   + 限界上下文就是一个非常好的接缝，因为它的定义就是组织内高内聚和低耦合的边界。

2. 如何分解？

   + 首先，我们先要识别当前巨大的后台单块服务能够映射到哪些限界上下文中，如MusicCorp这个系统能够映射如下4个上下文：产品目录，财务，仓库，推荐。然后，将当前的代码围绕着这4个接缝进行重新组织，把已有代码移动到相应的位置。

3. 分解单块系统的原因

   决定把单块系统变小是一个很好的开始，但建议慢慢地进行拆分，增量的方式可以让你在进行的过程中学习微服务，同时也可以限制出错所造成的影响。

   + 改变的速度：我们可能会对库存管理方面的代码做大量修改，把仓库接缝抽出来作为一个服务，使其成为一个自治单元，那么后期开发的速度将大大加快。
   + 团队结构：有可能因为团队因素的原因，而需要把原团队维护的大部分代码分离出来，这样另一个团队就能对此全权负责（比如：微信支付完整拆分出大单交接给广州团队）；
   + 安全因素：比如某些大型服务具备安全审计的机制，并且决定对敏感信息做更加严密的保护。目前这部分功能由财务相关的代码处理。如果把这个服务分出去，可以对这个独立的服务做监控，传输数据的保护和静态数据的保护等。
   + 技术因素：比如维护推荐系统的团队研究出了一种新的算法，这种算法使用了Clojure语言中逻辑式编程的库，并且认为这能够大大改善我们的服务。如果能把这部分推荐代码分离到一个单独的服务中，就很容易重新实现一遍，并对其进行测试。

4. 杂乱的依赖

   当你已经识别出了一些备选接缝，另一个需要考虑的点是，这部分代码与系统剩余部分之间的依赖有多乱。我们想要拉取出来的接缝应该尽量少地被其他组件所依赖。如果你识别出来的几个接缝之间可以形成一个有向无环图，就能够看出来哪些接缝会比较难处理。

   通常经过这样的分析就会发现，数据库是所有杂乱依赖的源头。

5. 数据库：对于要把数据库作为接缝进行服务之间的分离，数据库是个棘手的存在。

6. 找到分离数据库的依赖的关键

   首先要了解清楚当前系统对数据库进行读写的部分，是如何运作的，判断清楚用到了哪些表和约束。

7. 打破原来同库不同表之间的外键依赖：

   比如MusicCrop单块服务包含**产品目录**和**财务**两个限界上下文，产品目录访问行条目表，财务访问行条目表和总账表，总账表和行条目表之间存在外键依赖。修改的方法有：让财务部分的代码通过产品目录服务暴露的API来访问数据，而不是直接访问数据库。但是这样，需要做两次数据库调用来生成报告（由于是两个独立的服务）。

   + 很多人会对性能表示担忧。但是其实，有时候让系统的一部分变慢会带来更大的好处，尤其当这个“慢”事实上还在可接受的范围内。


   + 那么外键关联呢？我们可以放弃它，我们可能需要把这个约束从数据库移到代码中来实现。这也意味着，我们可能需要实现跨服务的一致性检查，或者周期性触发清理数据的任务。

8. 处理共享静态数据

   比如把国家名称及其简称放在数据库中，相当于静态数据一样。如果所有的服务都要从同一张像这样的数据表读取数据，要怎么办？可以解决的方案有：

   + 为每个服务（包）复制一份该表的内容，也就是说，未来每个服务都会保存这样一份副本。当然这会导致一个潜在的一致性问题。比如新增数据项时，有可能会漏修改掉一些服务中的副本数据。
   + 第二个方法，把这些共享的静态数据放入代码，比如放在配置文件，属性文件中，或者简单地放在一个枚举中。数据一致性的问题仍然存在，虽然从经验上看，修改配置文件比修改在线数据库要简单得多。通常这是比较合理的方法。
   + 第三个方法有些极端，即把这些静态数据放入一个单独的服务中。在我以前遇到过的一些场景中，数据量和复杂性及相关的规则值得我们这样做，但如果仅仅是国家代码的话就不必了。

9. 处理共享动态数据

   共享的可变数据对于分离系统来说通常是一个大麻烦。比如仓库服务和财务服务目前只访问一张客户记录表。这里暴露出一个问题：领域概念不是在代码中进行建模，相反是在数据库中隐式地进行建模。这里缺失的领域概念是客户。

   所以，我们首先要新建一个服务叫客户服务，让财务和仓库服务通过API来访问新创建的服务。（**拆新服务**)

10. 处理共享表

    比如例子中，产品目录和仓库原来都访问同张表，但是可以对仓库创建库存项表，对产品目录详情创建产品目录项表。

11. 重构数据库

    实施分离的步骤：从单一表结构（单块服务访问单块表结构）演变成分离表结构（单块服务访问多个表，先拆表）到最后的把应用程序分成两个服务（多个服务访问多个表，拆服务）。

    + 表结构分离之后，对于原先的某个动作而言，对数据库的访问次数可能会变多。因为以前简单地用一个select语句就能得到所有的数据，现在则需要分别从不同的地方拿到数据，然后在内存中进行连接。还有，分成两个表结构会破坏事务完整性，这会对应用程序造成很大的影响。
    + 先分离数据库结构但不分离服务的好处在于，可以随时选择回退这些修改或是继续做，而不影响服务的任何消费者。我们对数据库分离感到满意之后，再考虑分离服务。

12. 事务边界

    使用单块表结构时，所有的创建或者更新操作都可以在一个事务边界内完成。分离数据库之后，这种好处就没有了。

    但是，如果我们已经把表分成了两部分，其中一个与客户相关，其余的与仓库相关，那么就无法获得事务所能提供的安全性。操作已经跨越了两个事务边界，那么怎么保证状态一致性呢？

    + **再试一次**：把部分的某些操作放在一个队列或者日志文件中，之后再尝试对其进行触发。对于某些操作来说这是合理的，但要保证重试能够修复这个问题。这种形式叫做**最终一致性**。
    + **终止整个操作（Rollback）**：另一个选择是拒绝整个操作。在这种情况下，我们需要把系统重置到某种一致的状态。前一张表的处理比较简单，因为插入失败会导致事务的回退。但是后一张表已经提交了的事务该怎么处理呢？解决方法是：再发起一个**补偿事务**来抵消之前的操作。补偿事务的操作可能会有很多很多，比如删除数据，通知用户操作失败等。但是如果补偿事务失败了该怎么办？在这种情况下，要么重试补偿事务，要么使用一些后台任务来清除这些不一致的状态。可以给后台的维护人员提供一个界面来进行操作，或者将其自动化。一旦补偿事务的个数多起来了，理解起来就没那么容易了。
    + **分布式事务**：分布式事务会横跨多个事务，然后使用一个叫做**事务管理器**的工具来统一编配其他底层系统中运行的事务。就像普通的事务一样，一个分布式事务会保证整个系统处于一致的状态。唯一不同的是，这里的事务会运行在不同系统的不同进程中，通常它们之间使用网络进行通信。
      + 处理分布式事务常用的算法是两阶段提交。在这种方式中，首先是投票阶段。在这个阶段，每个参与者(cohort)会告诉事务管理器它是否应该继续。如果事务管理器收到的所有投票都是成功的，则会告知它们进行提交操作。只要收到一个否定的投票，事务管理器就会让所有的参与者回退。
      + 这种方式会使得所有的参与者暂停并等待中央协调进程的指令，从而很容易导致系统的中断。如果事务管理器宕机了，处于等待状态的事务就永远无法完成。如果一个cohort在投票阶段发送消息失败了，则所有的其他参与者都会被阻塞，投票结束之后的提交也有可能会失败。该算法隐式地认为上述情况不会发生，即如果一个cohort在投票阶段投了赞成票，则它一定能提交成功。cohort需要一种机制来保证这件事情的发生。这意味着此算法并不是万无一失的，而只是尝试捕获大部分的失败场景。
      + 协调进程也会使用锁，也就是说，进行中的事务可能会对某些资源持有一个锁。很多人会对在资源上加锁有担忧，因为它会使系统很难扩展，尤其是在分布式系统的上下文中。

13. 上述方案应该如何选择？

    ​        所有的这些方案都会增加复杂性。分布式事务很容易出错，而且不利于扩展。这种通过重试和补偿达成最终一致性的方式，会使得定位问题更加困难，而且有可能需要其他的补偿措施来修复潜在数据的不一致。

    ​        所以，如果你遇到的场景确实需要保持一致性，那么尽量避免把它们放在不同的地方，一定要尽量这样做。如果实在不行，那么要避免仅仅从纯技术（比如数据库事务）的角度考虑，而是显式地创建一个概念来表示这个事务。你可以把这个概念当作一个句柄或者钩子，在此之上，能够相对容易地进行类似补偿事务这样的操作，这也是在系统中监控这些复杂概念的一种方式。举个例子，你可以创建一个叫作”处理中的订单“的概念，围绕这个概念可以把所有与订单相关的端到端操作（及相应的异常）管理起来。

14. 报告（上报，出报表）

    我们在对服务，对数据库存储进行分离。但在操作的过程中，会遇到一个常见的问题，就是报告。

    把架构往微服务的方向进行调整会颠覆很多东西，但这并不意味着我们需要抛弃现有的一切。报告系统的用户和其他用户一样，他们的需求也应该得到满足。修改架构然后让用户去适应，这种做法也未免太过傲慢。

15. 报告数据库

    原来的做法：单块服务读/写主数据库，报告系统读报告服务本数据，两个数据库之间通过主备同步完成。

    这种做法的好处：所有的数据存储在同一个地方，因为可以使用非常简单的工具来做查询。

    缺点：数据库结构成了单块服务和报告系统之间的共享API，所以对表结构的修改需要非常小心。事实上，这也会阻碍所有人去做类似的修改。

    其次，无论是在线上系统还是报告系统的数据库中，可用的优化手段都比较有限。一些数据库允许我们在只读的备份库上做一些优化，以加快读取速度，从而更高效地生成报告。比如在MySQL中停用事务管理。但由于产品数据库的限制，报告数据库的表结构是无法随意优化的。

    最后，对于报告服务的数据处理，我们可能在以后需要新技术，新的数据库。

    所以，下面有多种不同的替代方案。

16. 通过服务调用来获取数据

    依赖API来获取数据，但是这只适合用来查询单体数据，比如根据ID来查询客户，或者根据一些字段来搜索客户，但是客户服务不会提供API来获取所有的客户数据。

    因此，对于某些服务暴露的资源来说，可以通过添加一些缓存头来加快数据的获取速度，还可以把这些数据缓存在反向代理之类的地方。但是报告天然就允许用户访问不同时期的历史数据，这意味着，如果用户访问的资源是别人没有访问过的（或者在很长一段时间内没有人访问），则缓存无法命中。

    也可以提供批量API来简化这个过程。比如要求可以传过来一组客户ID来批量获取数据，提供批量查询的接口，或者提供一个接口来进行分页访问数据。但是过多的数据也会受数据包大小的影响，大包容易受带宽等因素的影响。

17. 数据导出

    和报告系统拉取数据的方式相比，我们还可以把数据推送到报告系统中。但是，使用标准的HTTP来进行大量调用时，会带来很大的额外开销，更不用提为报告系统创建专用API所带来的开销。一种替代方式是，使用一个独立的程序直接访问其他服务使用的那些数据库（使用脚本工具进行导数据操作），把这些数据导出到单独的报告数据库。（比如支付订单库的增量数据导入功能）

    一开始，相应服务的维护团队可以负责数据的导出工作。简单地使用Cron去触发一些命令行程序就可以完成这个任务。这个程序需要同时使用服务和报告系统的数据库。导出任务的职责是，把一种形式映射成为另一种形式。通过让同一个团队来维护服务本身和数据导出，可以缓解二者之间的耦合。事实上，我会建议你对服务和数据导出程序统一做版本管理，并且把数据导出的构建，作为服务本身构建的一个生成物给创建出来，当然这里假设服务和报告总是同时部署的。因为二者总是一起部署，而且服务和报告系统之外的实体不会访问这些数据，所以传统的数据库集成所带来的问题，很大程度上得到了缓解。

    还有就是使用数据库的视图之类的技术来创建一个聚合。使用这种方式，导出数据的服务只需要知道自己的报告视图结构即可。但是这种方式的性能取决于你所选用的数据库系统了。

18. **事件数据导出**

    之前说过，每个微服务可以在其管理的实体发生状态时发送一些事件。比如，我们的客户服务可能会在客户增删改时发送一些事件。对于这些暴露事件聚合的微服务来说，可以编写自己的事件订阅器把数据导出到报告数据库中。

    使用这种方式的话，与源微服务底层数据库之间的耦合就被消除掉了。我们只需要绑定到服务所发送的事件即可，而设计这些事件，本来就是用来暴露给外部消费这的。考虑事件是具有时效性的，也很容易确定什么样的数据应该被发送到中央报告系统的存储中。因为可以在事件发生时就给报告系统发送数据，而不是靠原有的周期性数据导出，所以数据就能更快地流入系统。

    还有，如果我们记录了哪些事件已经被处理，而且发现老的事件已经被导入到报告系统中，那么每次只需要对新事件进行处理即可。这意味着插入操作会更加高效，因为只需要发送增量数据。我们可以在数据导出的方式中做类似的事情，但是需要自己实现，然而事件流（x在时间戳y上发生）的时效性能够帮我们很好地完成这个目标。

    因为事件数据导出的方式与服务的内部实现耦合很小，所以可以把这部分工作交给另一个独立的团队（而非持有数据的那个团队）来维护。只要事件流的设计没有造成订阅者和服务之间的耦合，则这个事件映射器就可以独立于它所订阅的服务来进行演化。

    这个方法主要的**缺点**是，所有需要的信息都必须以事件的形式广播出去，所以在数据量比较大时，不容易像数据导出那样直接在数据库级别进行扩展。不管怎样，如果你已经暴露出了合适的事件，我还是建议你考虑这种方式，因为它能够带来低耦合及更好的数据时效性。

19. 数据导出的备份

    比如Netflix的Cassandra，可以了解一下。

20. 走向实时

    前面列出了很多数据从不同的地方汇聚到同一个地方的模式。但是否所有的报告都必须从一个地方出呢？后面我们会改造成能够把数据按需路由到多个不同地方的通用事件系统了。

21. 修改的代价

    又有每次的修改都伴随着很高的代价，我建议在这个过程可以采用CRC（类-职责-交互）方法。在一张卡片写上类的名字，它的职责及与谁进行交互。当我进行设计时，会把每个服务的职责列出来，写清楚它提供了什么能力，和哪些服务之间有协作关系。遍历的用例越多，你就越能知道这些组件是否以正确的方式在一起工作。 

    ​