### Chapter7.测试

1. 测试类型

   处于象限底部的有**面向技术**的测试，然后一直到顶端有**面向业务**的测试。具体可以了解下，测试有关的象限，X轴（支持团队——>评价产品），Y轴（面向技术——>面向业务）。

   区间：

   + 验收测试：我们是否实现了正确的功能？（自动化，Fit-Finesse等）；
   + 探索性测试：可用性测试，我如何破坏系统功能；（手工）
   + 单元测试：我们是否正确地实现了功能？（自动化的，xUnix系统框架）
   + 非功能性测试：响应时间，可扩展性，性能测试，安全测试等（工具）；

2. 测试范围

   测试金字塔：底层是单元测试，其次是服务测试，最顶端是用户界面测试。自底而上范围更大，更有信心。

   + 单元测试：单元测试通常只测试一个函数和方法调用。单元测试是帮助我们开发人员的，是面向技术而非面向业务的。这些测试的主要目的是，能够对于功能是否正常快速给出反馈。单元测试对于代码重构非常重要，因为我们知道，如果不小心犯了错误，这些小范围的测试能很快做出提醒，这样我们就可以放心地随时调整代码。
   + 服务测试：只测试一个单独的服务可以提高测试的隔离性，这样我们就可以更快地定位并解决问题。为了达到这种隔离性，我们需要给所有的外部合作者打桩，以便只把服务本身保留在测试范围内。
   + 端到端测试：会覆盖大范围的产品代码。但是伴随着覆盖范围的增大，一些在使用微服务过程中很难消除的负作用也会随之而来。
   + 权衡：金字塔顶端，覆盖范围越大，需要时长更多。
   + 比例：一个好的经验法则是，顺着金字塔下，下面一层的测试数量要比上面一层多一个数量级。

3. 实现服务测试

   + 打桩与mock：是指为被测服务的请求创建一些有着预设响应的打桩服务。另一种替代打桩的方式是mock。mock还会进一步验证请求本身是否被正确调用。如果与期望请求不匹配，测试便会失败，但过度使用mock会让测试变得脆弱。
   + 智能的打桩服务：很多人都自己创建打桩服务，但其实业界已经有很多的成熟组件，比如Mountebank。

4. 微妙的端到端测试

   服务流水线的构造：构建——>单元测试——>服务测试。在此基础上，让多个流水线扇入到一个独立的端到端测试的阶段。任意一个服务的构建都会触发一次端到端测试，但其实有很多的缺点。

5. 端到端测试的缺点：下面有。

6. 脆弱的测试：包含在测试中的服务数量越多，测试就会越脆弱，不确定性也就越强。而且更严重的问题是，容易引入**异常正常化**。

   **异常正常化**：当发现脆弱的测试时，我们应该竭尽全力去解决这个问题。否则，人们就会开始对测试套件失去信心，因为它们”总是这样失败“。也就是说，随着时间的推移，我们对事情出错变得习以为常，并开始接受它们是正常的。因为人类有这种倾向，所以在开始接受失败测试是正常的之前，应该尽快找到这些脆弱的测试并消除它们。

   **谁来写这些测试**：

   + 一种情况是，这些测试对所有人开放，所有团队成员都可以在无须对测试套件质量有任何理解的情况下随意添加测试。这往往会导致测试用例爆炸，有时甚至会导致我们前面谈到的测试甜筒。因为测试没有真正的拥有者，所以它们的结果会被忽略。当测试失败后，每个人都认为是别人的问题，大家根本不在乎测试是否通过；
   + 有些组织则是由一个专门的团队来写这些测试。这可能是灾难性的。开发软件的人渐渐远离测试代码，周期时间会变长，因为服务的拥有者实现功能需要等待测试团队来写端到端测试。因为这些测试由别的团队编写，实现服务的团队很少参与，所以很难了解如何运行和修复这些测试。很不幸，这是一个非常常见的组织模式，只要团队没有在第一时间测试自己所写的代码，就会出现很大的问题。
   + 如何权衡？最好的平衡是共享端到端的测试套件的代码权，但同时对测试套件联合负责。团队可以随意提交测试到这个套件，但实现服务的团队必须全都负责维护套件的健康。

   **测试多长时间**：一套完整的回归测试耗时长，但是删除测试往往更让人担忧。

   **大量的堆积**：在修复失败的端到端测试的同时，上游团队一直在提交更多的变更。结果是，除了使修复构建更加困难外，要部署的变更内容也多了。解决这个问题的一个方法是，端到端测试失败后禁止提交代码，但考虑到测试套件的运行时间过长，这个要求通常是不切实际的。

   **元版本**：不能单纯为了方便端到端测试而选择整个系统使用同一个版本号。这种情况过于糟糕。

7. 测试场景，而不是故事

   如果我们掉进陷阱，为每一个新添加的功能增加一个新的端到端测试，那么这种情况会加剧恶化。当你给我展示每实现一个新的故事便添加一个新的端到端测试的代码库时，将会有一个臃肿的测试套件，很长的反馈周期和巨大的重叠测试覆盖率。

8. 拯救消费者驱动的测试

   了解CDC（消费者驱动的契约）的概念：试图确保部署新的服务到生产环境后，变更不会破坏新服务的消费者。有一种不需要使用真正的消费者也能达到同样目的方式。

   **Pact**是一个消费者驱动的测试工具，在github上搜索Pact可以了解一下。（本地mock服务）;

   CDC需要消费者和生产服务之间具有良好的沟通和信任。

9. 还应该使用端到端测试吗

   可以把运行端到端测试当作把服务部署到生产环节的辅助轮。

10. 部署后再测试

    大多数测试会在系统部署到生产环境之前完成。但如果我们的模型并不完美，那么系统在面对愤怒的使用者时就会出现问题。缺陷会溜进生产环境，新的失效模式会出现，用户也会以我们意想不到的方式来使用系统。

11. 蓝/绿部署

    蓝/绿部署的几个步骤：1.部署新版本；2.运行冒烟测试；3.切换流量。

    实施蓝/绿部署有几个前提条件：首先，需要能够切换生产流量到不同的主机（或主机集群）上。切换可以通过改变DNS条目，或更改负载均衡的配置。你还需要提供足够多的主机，以支持并行运行两个版本的微服务。如果你正在使用一个弹性云提供商，这个要求对你来说可能很简单。使用蓝/绿部署可以降低风险，也让你有能力在遇到问题时尽快恢复。如果做得足够好，整个过程可以完全自动化，在无需人工干预的情况下完整地部署或恢复。

    保持旧版本运行，除了给予我们在切换生产流量前可以测试服务这个好处外，还可以大幅度地减少发布软件所需要的停机时间。使用某些生产流量重定向的机制时，我们甚至可以做到客户无感知的情况下进行版本切换，达到零宕机部署。

12. 金丝雀发布

    金丝雀发布是指通过将部分生产流量引流到新部署的系统，来验证系统是否按预期执行。”按预期执行“可以涵盖很多内容，包括功能性的和非功能性的。甚至更进一步，如果我们要发布一个新版本的推荐服务，可以同时运行两个版本，然后看看新版本的推荐服务是否能够达到预期的销售量，以确保我们没有发布一个次有算法的服务。如果新版本没有达到预期，我们可以迅速恢复到旧版本。我们可以引导更多的流量到新版本。金丝雀发布与蓝/绿发布的不同之处在于，新旧版本共存的时间更长，而且经常会调整流量。

    当考虑使用金丝雀发布时，你需要选择是要引导部分生产请求到金丝雀，还是直接复制一份生产请求。有些团队选择先复制一份生产请求，然后引导复制的请求到金丝雀。使用这种方法，现运行的生产版本和金丝雀版本可以有相同的请求，只是生产环境的请求结果是外部可见的。这方便大家对新旧版本做比较，同时又避免假如金丝雀失败，影响到客户的请求。不过，复制生产请求的工作可能会很复杂，尤其是在事件/请求不是幂等的情况下。

13. 平均修复时间（MTTR）胜过平均故障间隔时间（MTBF)

    减少修复时间的技术可以简单到尽快回滚加上良好的监控，类似蓝/绿部署。如果我们能早点发现生产中的问题，尽快回滚，就可以减少对客户的影响。

14. 跨功能的测试（CFR)：代指非功能性需求，包含：

    + 性能测试：压测，追踪系统数据瓶颈和合理性。测试完一定要看结果，从结果看出当前系统是否合理，是否出现访问瓶颈。

15. 参考书籍：《敏捷软件测试》。